"""
d: 부서별로 신청한 금액이 들어있음
budget: 회사가 지원 가능한 예산

문제: 최대 몇 개의 부서에 물품을 지원할 수 있는가

"""
# ************ #
"""
"최대 몇 개의 부서"이므로, 제한된 예산을 가지고 가장 많이 지원할 수 있는 범위를 생각한다.
즉, 신청 금액이 적은 부서 순서대로 묶으면 된다
"""

# 나의 풀이
def solution(d, budget): 
    d=sorted(d) # 오름차순으로 정렬한다. d가 작은 순서대로이다
    cnt=0  # 몇 개의 부서를 지원했는지 카운트하는 변수
    for i in d: # 정렬한 d를 하나씩 탐색한다
        budget-=i #예산에서 빼주고, 예산이 다 닳을 때까지 탐색한다
        if budget<0: break
        cnt+=1
    return cnt

"""
테스트 1 〉	통과 (0.00ms, 10.1MB)
테스트 2 〉	통과 (0.00ms, 10.1MB)
테스트 3 〉	통과 (0.00ms, 10.1MB)
테스트 4 〉	통과 (0.00ms, 10.1MB)
테스트 5 〉	통과 (0.00ms, 10.3MB)
테스트 6 〉	통과 (0.00ms, 10.1MB)
테스트 7 〉	통과 (0.02ms, 10.2MB)
테스트 8 〉	통과 (0.01ms, 10.2MB)
테스트 9 〉	통과 (0.01ms, 10.2MB)
테스트 10 〉	통과 (0.01ms, 10.1MB)
테스트 11 〉	통과 (0.01ms, 10.1MB)
테스트 12 〉	통과 (0.01ms, 10.3MB)
테스트 13 〉	통과 (0.01ms, 10.1MB)
테스트 14 〉	통과 (0.01ms, 10.1MB)
테스트 15 〉	통과 (0.01ms, 10.1MB)
테스트 16 〉	통과 (0.01ms, 10.1MB)
테스트 17 〉	통과 (0.02ms, 10.1MB)
테스트 18 〉	통과 (0.02ms, 10.1MB)
테스트 19 〉	통과 (0.01ms, 10.2MB)
테스트 20 〉	통과 (0.01ms, 10.1MB)
테스트 21 〉	통과 (0.01ms, 10.3MB)
테스트 22 〉	통과 (0.01ms, 10.3MB)
테스트 23 〉	통과 (0.01ms, 10.1MB)
"""

# 풀이2

def solution(d,budget):
    d.sort() # 정렬
    while budget<sum(d):
        d.pop()
    return len(d)

    """
    d=[1,2,3,4,5]
    d.pop() ==> 5 ==> d: [1,2,3,4]
    d.pop(0) ==> 1 ==> d:[2,3,4]
    """